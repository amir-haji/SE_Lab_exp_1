# آزمایشگاه مهندسی نرم‌افزار - آزمایش اول

اعضای گروه:
امیرحسین حاجی محمد رضایی - ۹۹۱۰۹۲۵۲

علی رازقندی - ۹۹۱۰۹۲۹۶

سید رضا قمقام - ۹۹۱۷۰۵۴۲

لینک صفحه ایجاد‌شده: https://amir-haji.github.io/SE_Lab_exp_1/
## گزارش 
در اینجا بخشی از اعمال انجام‌شده جهت توسعه برنامه در این مخزت را توضیح می‌دهم:
در ابتدا برای محافظت از شاخه اصلی باید یک قانون محافظت تعریف کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/branch_protection.png)
در این بخش با تعیین الگو اسم شاخه، دیگر نمیتوان به طور مستقسیم به شاخه اصلی تغییرات ایجاد و نیاز به ایجاد درخواست تغییرات می‌باشد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/protection_set.png)
بعد از این مرحله، فایل‌های مربوط به برنامه را اضافه می‌کنیم. در این تصویر یک روند ایجاد شاخه فرعی و ایجاد تغییرات در مخزن از روی مخزن محای نشان داده شده است:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/git_overview.png)
بعد از این مرحله تنظیمات استقرار را انجام می‌دهم که برای آن از یک فایل در مسیر .github/workflows استفاده می‌کنم:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/deploy_config.png)
بعد از ایجاد فایل میتوان در بخش actions نتیجه آن را مشاهده کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/actions.png)
و در آخر با رفتن به بخش Pages آدرس صفحه ایجاد شده را دید. در اینجا تصویر صفحه ایجاد‌شده را مشاهده می‌کنید:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/web_overview.png)
در روند ایجاد برنامه دو کانلیکت نیز ایجاد شده است که رفع یکی از آنها را در اینجا توضیح می‌دهم. در ابتدا همانطور که مشاهده می‌کنید بین این دو شاخه کانلیکت وجود دارپ.
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict1-part1.png)
بعد از آن با ایجاد pull request میتوان با استفاده از امکانات در github تغییرات دو فایل را مشاهده کرد و کانفلیکت را رفع کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict1%20-%20part%202.png)
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%201%20-%20part%203.png)
در نهایت با رفع کانفلیکت میتوان این دوشاخه را با هم مرج کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%201%20-%20part%204.png)
همین روند را میتوان بر روی این کانفلیکت نیز انجام داد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%202%20-%20part%201.png)


## Q1
پوشه .git یک پوشه مخفی برای ریپازیتوری ایجاد شده است که در آن اطلاعات تمام اشیا و ریفرنس‌های مربوط به ریپازیتوری نگه داشته شده است تا بتواند تارخچه تمام تغییرات ایجاد شدخ در مخزن را دنبال کند. این پوشه با استفاده از دستور git init در یک پوشه ایجاد می‌شود و در واقع پوشه‌ای که در آن این دستور وارد شده باشد را به‌عنوان مخزن درنظر می‌گیرد.

## Q2
مفهوم atomic بودن به صورت کلی به این معناست که هرعمل یا تغییری که در یک سیستم انجام می‌شود تاحد کافی کوچک باشد، به این معنا که این تغییر بسیار پیچیده نباشد و چندین مفهوم را در برنگیرد.

از همین مفهوم در مورد commit ها و pull request ها استفاده می‌شود. atomic commit ها به کامیت‌هایی گفته می‌شوند که تغییر آنها تنها مربوط به یک feature یا رفع باگ و ... و چندین مفهوم و بخش کد درگیر این تغییر نباشند. همچنین اعمال این کامیت نباید باعث ایجاد خطاهای بسیار و ناپاینداری برنامه پیاده‌سازی شده باشد.

در مورد atomic pull request ها نیز مفهوم مشابهی وجود دارد. این pull request ها باید تنها شامل تغییرات مربوط به یک دامنه از برنامه مانند feature ها و یا رفع باگ و توسعه و ... شامل شوند. همچنین تغییراتی که در آنها وجود دارد باید تا جای ممکن کافی و به اندازه باشد. همچنین روند تغییران باید تا جای ممکن در آنها قابل خواند باشد تا تغییرات برای دیگران واضح باشد.

همانطور که مشخص است این نوع کامیت‌ها و pull request ها می‌توانند به ما کمک کنند که تغییرات در سیستم به صورت راحت‌تر قابل دنبال کردن باشد.

## Q3

1. fetch: این دستور اطلاعات جدید را از مخزن remote دریافت می‌کند، اما آن‌ها را با برنچ های local شما ادغام نمی‌کند. این عمل برای بررسی تغییرات قبل از اعمال آن‌ها مفید است.

2. pull: ترکیبی از دو عملیات fetch و merge است. ابتدا تغییرات را از مخزن remote دریافت می‌کند و سپس آن‌ها را با branch فعلی شما ادغام می‌کند.

3. merge: این دستور دو برنچ را با هم ترکیب می‌کند. یک کامیت جدید ایجاد می‌کند که تغییرات هر دو برنچ را در بر می‌گیرد.

4. rebase: این دستور تاریخچه کامیت‌ها را بازنویسی می‌کند. کامیت‌های یک برنچ را برداشته و آن‌ها را روی برنچ دیگر اعمال می‌کند. این کار تاریخچه خطی‌تری ایجاد می‌کند.

5. cherry-pick: این دستور به شما اجازه می‌دهد یک کامیت خاص را از یک برنچ انتخاب کرده و آن را روی برنچ دیگر اعمال کنید، بدون اینکه کل برنچ را ادغام کنید.


## Q4

1. reset: این دستور برای بازگرداندن HEAD و برنچ فعلی به یک کامیت خاص استفاده می‌شود. سه حالت دارد:
   - soft: فقط HEAD را تغییر می‌دهد.
   - mixed (پیش‌فرض): HEAD و ایندکس را تغییر می‌دهد.
   - hard: HEAD، ایندکس و دایرکتوری کاری را تغییر می‌دهد.

2. revert: یک کامیت جدید ایجاد می‌کند که تغییرات یک کامیت خاص را برعکس می‌کند. برای لغو تغییرات در تاریخچه عمومی مفید است.

3. restore: برای بازگرداندن فایل‌ها از استیج یا از یک کامیت خاص به دایرکتوری کاری استفاده می‌شود. جایگزین جدیدتری برای بخشی از عملکرد checkout است.

4. switch: برای تغییر برنچ فعال استفاده می‌شود. جایگزین جدیدتری برای بخش دیگری از عملکرد checkout است.

5. checkout: یک دستور چندمنظوره قدیمی‌تر است که می‌تواند برای تغییر برنچ ها بازیابی فایل ها و ایجاد برنچ های جدید استفاده شود. عملکردهای آن اکنون بین switch و restore تقسیم شده است.

تفاوت کلیدی این است که reset و revert بر روی کامیت‌ها کار می‌کنند، در حالی که restore بر روی فایل‌ها کار می‌کند. switch و checkout (در حالت تغییر برنچ) بر روی برنچ ها کار می‌کنند.

## Q5

1. زمانی که تغییری در پروژه شما ایحاد میشود میتوانید با کمک دستور git status تغییرات رو ببینید. بعد از اینکه گیت تغییرات پروژه شما رو فهمید اگر از تغییرات راضی بودید باید اقدام به ثبت تغییرات کنید. در گیت سه مرحله برای ثبت تغییرات وجود دارد. مرحله اول untracked یا modified است که نشاندهنده تغییرات یک فایل یا ایحاد شدن یک فایل است. بعد با دستور git add باید تغییرات رو به مرحله دوم یعنی staged ارسال کنید. این مرحله نشان دهنده رضایت شما از تغییرات ایجاد شده است. و در آخر برای ثبت کردن تغییرات باید با دستور git commit پروژتون رو به مرحله commited بفرستید.

2. دستور `git stash` به طور موقت تغییراتی را که ایجاد کرده‌اید، ذخیره می‌کند تا بتوانید روی کار دیگری تمرکز کنید و سپس به آن تغییرات بازگشته و آنها را دوباره اعمال کنید. ذخیره‌سازی با استفاده از `git stash` زمانی مفید است که نیاز دارید سریعاً زمینه کار خود را تغییر دهید و روی موضوع دیگری کار کنید، اما در میانه‌ی تغییرات هستید و هنوز آماده‌ی  commit آن تغییرات نیستید.

##  Q6

مفهوم snapshot به معنای وضعیت یک چیز مانند داده ها یا فایل ها در یک پروژه در یک زمان خاص است.
هر کامیت در git در واقع یک snapshot است.
در وافع یک snapshot یک نمایندگی از وضعیت فعلی فایل‌های پیگیری شده شما است که به صورت یک فهرست (manifest) ارائه می‌شود و می‌توان آن را با دیگر فهرست‌ها مقایسه کرد تا تفاوت‌ها را مشاهده کنید.

Git فقط تفاوت‌های بین فهرست‌ها را از لحظه‌ای که برای اولین بار پیگیری شده‌اند ردیابی می‌کند. اگر یک فایل از آن زمان که برای اولین بار پیگیری شده‌است تغییر نکرده باشد، همه snapshot‌های بعدی به اولین snapshot ارجاع می‌دهند. اگر فایل تغییر کرده باشد، همه snapshot‌های بعدی به snapshotی ارجح می‌دهند که دارای تغییرات اخیرترین است. آنچه Git ذخیره می‌کند در واقع یک تاریخچه پیوسته از snapshot‌ها از آخرین تا اولین است. یک شاخه اساساً یک تقسیم‌بندی در زمان است که امکان زنجیره‌ای تاریخی جایگزین از snapshot‌ها را از یک snapshot خاص در زنجیره اصلی فراهم می‌کند.

در git بعد از هر کامیت یک اسنپ شات جدید ذخیره میشود.

در این snapshot ها فقط تغییرتی که نسبت به snapshot قبلی ایجاد شده است ذخیره میشود.

این امر به git کمک میکند تا بسیار بهینه تر از فضای ابری استفاده کند و هر بار تمام پروژه را ذخیره نکند.

تاریخچه پروژه در Git به عنوان یک زنجیره از snapshots ذخیره می‌شود. هر snapshot یا commit به snapshot قبلی مرتبط است، به طوری که شما می‌توانید به هر نقطه‌ای در تاریخچه پروژه بازگردید و وضعیت آن را مشاهده کنید.

همچنین snapshot این امکان را فراهم میکند تا به راحتی به تسخه های قبلی بازگردیم.

در یک کلام میتوان گفت snapshots در Git اساس مدیریت نسخه‌ها و تاریخچه پروژه را تشکیل می‌دهند.

snapshot به معنایی شبیه یک عکس از وضعیت فایل های موجود در پروژه است. ارتباط آن با commit این است مه این عکس بعد از هر کامیت گرفته میشود. در هر snappshot تمام اطلاعات دوباره ذخیره نمیشود بلکه فقط قسمت های تغییر کرده به snapshot قبلی اضافه میشود. این امر به بهینه شدن ذخیره سازی در گیت کمک قابل توجهی میکند.



##  Q7

مخزن محلی:
- مخزن محلی، مخزنی است که بر روی دستگاه محلی شما وجود دارد. وقتی یک مخزن را از یک مکان ریموت clone می‌کنید، یک کپی محلی از آن را بر روی دستگاه خود ایجاد می‌کنید.
- مخزن محلی شامل تمام تاریخچه پروژه است، شامل تمام شاخه‌ها، commit‌ها و فایل‌ها.
- توسعه‌دهندگان در مخزن‌های محلی خود برای ایجاد تغییرات در کد، ایجاد شاخه‌های جدید، commit تغییرات و غیره کار می‌کنند.
- تغییرات اعمال شده در مخزن محلی تا زمانی که به یک مخزن ریموت push نشوند، برای دیگران قابل مشاهده نیستند.

مخزن ریموت:
- مخزن ریموت، یک مخزن است که بر روی یک سرور ریموت میزبانی می‌شود، مانند GitHub، GitLab، Bitbucket یا یک سرور سفارشی.
- مخزن‌های ریموت بین چندین توسعه‌دهنده که بر روی یک پروژه مشترک کار می‌کنند، به اشتراک گذاشته می‌شوند. آنها به عنوان نقطه مرکزی عمل می‌کنند که توسعه‌دهندگان می‌توانند تغییرات خود را push کنند و تغییرات اعمال شده توسط دیگران را pull کنند.
- توسعه‌دهندگان می‌توانند یک مخزن ریموت را clone کنند تا یک کپی محلی بر روی دستگاه خود ایجاد کنند. این امکان به آنها می‌دهد که بر روی کد کار کنند و تغییرات خود را با مخزن ریموت همگام کنند.
- مخزن‌های ریموت برای همکاری، پشتیبان‌گیری و به اشتراک‌گذاری کد با سایر اعضای تیم مفید هستند.

یک مخزن ریموت بر روی یک سرور میزبانی می‌شود (که می‌تواند در اینترنت باشد یا در یک سرور خارج از محل، حتی ممکن است در همان دستگاه باشد ولی در دایرکتوری متفاوت) و بین چندین عضو تیم به اشتراک گذاشته می‌شود.
اما یک مخزن محلی بر روی یک دستگاه محلی و فقط برای یک کاربر استفاده می‌شود.

طبیعتا تبادل داده در مخزن ریموت نیاز به اینترت دارد اما مخزن محلی خیر.

 به طور کلی نیازی به یک مخزن ریموت نیست. می‌توان تمام امکانات Git را با commit ها، شاخه‌ها، ادغام‌ها، rebases و غیره، فقط با یک مخزن محلی داشته باشیم .

هدف از یک مخزن ریموت (مانند GitHub) این است که کد خود را به جهان (یا به برخی افراد) منتشر کنید و به آنها اجازه بدهید که آن را بخوانند یا در آن نوشته‌های خود را اعمال کنند.

مخزن ریموت فقط در زمانی مورد استفاده قرار می‌گیرد که شما commit‌های محلی خود را به مخزن ریموت push کنید، یا commit‌های دیگران را با استفاده از git pull از آن بکشید.