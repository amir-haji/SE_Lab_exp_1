# آزمایشگاه مهندسی نرم‌افزار - آزمایش اول

اعضای گروه:
امیرحسین حاجی محمد رضایی - ۹۹۱۰۹۲۵۲

علی رازقندی - ۹۹۱۰۹۲۹۶

سید رضا قمقام - ۹۹۱۷۰۵۴۲

لینک صفحه ایجاد‌شده: https://amir-haji.github.io/SE_Lab_exp_1/
## گزارش 
در اینجا بخشی از اعمال انجام‌شده جهت توسعه برنامه در این مخزت را توضیح می‌دهم:
در ابتدا برای محافظت از شاخه اصلی باید یک قانون محافظت تعریف کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/branch_protection.png)
در این بخش با تعیین الگو اسم شاخه، دیگر نمیتوان به طور مستقسیم به شاخه اصلی تغییرات ایجاد و نیاز به ایجاد درخواست تغییرات می‌باشد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/protection_set.png)
بعد از این مرحله، فایل‌های مربوط به برنامه را اضافه می‌کنیم. در این تصویر یک روند ایجاد شاخه فرعی و ایجاد تغییرات در مخزن از روی مخزن محای نشان داده شده است:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/git_overview.png)
بعد از این مرحله تنظیمات استقرار را انجام می‌دهم که برای آن از یک فایل در مسیر .github/workflows استفاده می‌کنم:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/deploy_config.png)
بعد از ایجاد فایل میتوان در بخش actions نتیجه آن را مشاهده کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/actions.png)
و در آخر با رفتن به بخش Pages آدرس صفحه ایجاد شده را دید. در اینجا تصویر صفحه ایجاد‌شده را مشاهده می‌کنید:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/web_overview.png)
در روند ایجاد برنامه دو کانلیکت نیز ایجاد شده است که رفع یکی از آنها را در اینجا توضیح می‌دهم. در ابتدا همانطور که مشاهده می‌کنید بین این دو شاخه کانلیکت وجود دارپ.
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict1-part1.png)
بعد از آن با ایجاد pull request میتوان با استفاده از امکانات در github تغییرات دو فایل را مشاهده کرد و کانفلیکت را رفع کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict1%20-%20part%202.png)
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%201%20-%20part%203.png)
در نهایت با رفع کانفلیکت میتوان این دوشاخه را با هم مرج کرد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%201%20-%20part%204.png)
همین روند را میتوان بر روی این کانفلیکت نیز انجام داد:
![](https://github.com/amir-haji/SE_Lab_exp_1/blob/main/report_screenshots/conflict%202%20-%20part%201.png)


## Q1
پوشه .git یک پوشه مخفی برای ریپازیتوری ایجاد شده است که در آن اطلاعات تمام اشیا و ریفرنس‌های مربوط به ریپازیتوری نگه داشته شده است تا بتواند تارخچه تمام تغییرات ایجاد شدخ در مخزن را دنبال کند. این پوشه با استفاده از دستور git init در یک پوشه ایجاد می‌شود و در واقع پوشه‌ای که در آن این دستور وارد شده باشد را به‌عنوان مخزن درنظر می‌گیرد.

## Q2
مفهوم atomic بودن به صورت کلی به این معناست که هرعمل یا تغییری که در یک سیستم انجام می‌شود تاحد کافی کوچک باشد، به این معنا که این تغییر بسیار پیچیده نباشد و چندین مفهوم را در برنگیرد.

از همین مفهوم در مورد commit ها و pull request ها استفاده می‌شود. atomic commit ها به کامیت‌هایی گفته می‌شوند که تغییر آنها تنها مربوط به یک feature یا رفع باگ و ... و چندین مفهوم و بخش کد درگیر این تغییر نباشند. همچنین اعمال این کامیت نباید باعث ایجاد خطاهای بسیار و ناپاینداری برنامه پیاده‌سازی شده باشد.

در مورد atomic pull request ها نیز مفهوم مشابهی وجود دارد. این pull request ها باید تنها شامل تغییرات مربوط به یک دامنه از برنامه مانند feature ها و یا رفع باگ و توسعه و ... شامل شوند. همچنین تغییراتی که در آنها وجود دارد باید تا جای ممکن کافی و به اندازه باشد. همچنین روند تغییران باید تا جای ممکن در آنها قابل خواند باشد تا تغییرات برای دیگران واضح باشد.

همانطور که مشخص است این نوع کامیت‌ها و pull request ها می‌توانند به ما کمک کنند که تغییرات در سیستم به صورت راحت‌تر قابل دنبال کردن باشد.

## Q3

1. fetch: این دستور اطلاعات جدید را از مخزن remote دریافت می‌کند، اما آن‌ها را با برنچ های local شما ادغام نمی‌کند. این عمل برای بررسی تغییرات قبل از اعمال آن‌ها مفید است.

2. pull: ترکیبی از دو عملیات fetch و merge است. ابتدا تغییرات را از مخزن remote دریافت می‌کند و سپس آن‌ها را با branch فعلی شما ادغام می‌کند.

3. merge: این دستور دو برنچ را با هم ترکیب می‌کند. یک کامیت جدید ایجاد می‌کند که تغییرات هر دو برنچ را در بر می‌گیرد.

4. rebase: این دستور تاریخچه کامیت‌ها را بازنویسی می‌کند. کامیت‌های یک برنچ را برداشته و آن‌ها را روی برنچ دیگر اعمال می‌کند. این کار تاریخچه خطی‌تری ایجاد می‌کند.

5. cherry-pick: این دستور به شما اجازه می‌دهد یک کامیت خاص را از یک برنچ انتخاب کرده و آن را روی برنچ دیگر اعمال کنید، بدون اینکه کل برنچ را ادغام کنید.


## Q4

1. reset: این دستور برای بازگرداندن HEAD و برنچ فعلی به یک کامیت خاص استفاده می‌شود. سه حالت دارد:
   - soft: فقط HEAD را تغییر می‌دهد.
   - mixed (پیش‌فرض): HEAD و ایندکس را تغییر می‌دهد.
   - hard: HEAD، ایندکس و دایرکتوری کاری را تغییر می‌دهد.

2. revert: یک کامیت جدید ایجاد می‌کند که تغییرات یک کامیت خاص را برعکس می‌کند. برای لغو تغییرات در تاریخچه عمومی مفید است.

3. restore: برای بازگرداندن فایل‌ها از استیج یا از یک کامیت خاص به دایرکتوری کاری استفاده می‌شود. جایگزین جدیدتری برای بخشی از عملکرد checkout است.

4. switch: برای تغییر برنچ فعال استفاده می‌شود. جایگزین جدیدتری برای بخش دیگری از عملکرد checkout است.

5. checkout: یک دستور چندمنظوره قدیمی‌تر است که می‌تواند برای تغییر برنچ ها بازیابی فایل ها و ایجاد برنچ های جدید استفاده شود. عملکردهای آن اکنون بین switch و restore تقسیم شده است.

تفاوت کلیدی این است که reset و revert بر روی کامیت‌ها کار می‌کنند، در حالی که restore بر روی فایل‌ها کار می‌کند. switch و checkout (در حالت تغییر برنچ) بر روی برنچ ها کار می‌کنند.
